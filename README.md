
靠邀 寫完發現 我理解錯題目意思
是要先全部掃完決定c1, 再從頭掃一次決定c2
以後 SPEC 的內容一定要看清楚
以免浪費我玩樂的時間XD

我一開始以為:
走一遍就結束了
用一個持續移動的座標(counter)，先記住之前c1 c2圓心座標和覆蓋的點數
再用新座標要和40個點計算距離 覆蓋的點再和c1 c2比較
如果大 就更新圓心和點數
如果小 就維持
繼續往下找，直到走完 16 x 16
以為cycle數只需要 : 16 x 16 x 40 = 1w
模擬完發現題目要求5w以下，我才1w，以為自己很強
結果發現自己是小丑，多搞了一個上午(..Q Q..)


Other Method
方法一： 一次吃多個點
如果允許面積增加，可以：
* 一次比 **2 / 4 / 8 個點**
* sum 一次加多個 valid
實作方式：
* mem_x / mem_y 複製成 4-port
* 或 shift register + combinational compare

方法二：預先算距離 LUT
因為：
* 座標只有 4-bit
* 距離平方最大 15²+15² = 450
可以：
* 用 ROM / LUT
* `(dx, dy) → is_inside`
把乘法器全拿掉，cycle 不變但 critical path 大幅下降
把一張圖（0~15, 0~15）全部掃完，找出該輪這張圖裡的「全域最佳解」後，再切換狀態去修復另一個圓。
