靠邀，寫完才發現我**一開始就理解錯題目意思**。
正確流程其實是：**先完整掃描一輪決定 C1，再從頭掃一次決定 C2**。
這件事再次提醒我——**SPEC 真的要逐字看清楚**，不然只是在浪費我寶貴的玩樂時間 XD。

我原本的理解是：

> 只要走一遍就好。

設計上我用一個持續移動的座標（counter），一路掃過 16×16 的平面，同時記住目前的 C1、C2 圓心座標與各自覆蓋的點數。
每到一個新座標，就拿它去和 40 個點計算距離，算出覆蓋點數後，再與既有的 C1、C2 比較：

* 如果覆蓋點數比較大 → 更新圓心與點數
* 如果比較小 → 維持原狀

一路掃到 16×16 結束。

我還很得意地算了一下 cycle 數：
**16 × 16 × 40 = 約 1 萬 cycle**。
模擬完一看，題目要求 **5 萬 cycle 以下**，我才用 1 萬，當下還以為自己是天選之人。

結果後來才發現……
**不是我很強，是我完全搞錯題目** 🤡
白白多搞了一個上午（..Q Q..）。

提供其他思路參考
---

## Other Methods（延伸優化想法）

### 方法一：一次吃多個點

如果允許在同一個 cycle 內增加計算面積，可以考慮：

* 一次處理 **2 / 4 / 8 個點**
* 覆蓋點數一次累加多個 valid

實作方向包括：

* 將 `mem_x / mem_y` 複製成 **multi-port memory**
* 或使用 **shift register + combinational compare** 來平行比對

這種方式可以在不改變掃描策略的前提下，直接降低總 cycle 數。

---

### 方法二：預先計算距離 LUT

題目本身條件非常友善：

* 座標只有 **4-bit**
* 距離平方最大為
  [
  15^2 + 15^2 = 450
  ]

可以考慮：

* 用 **ROM / LUT**
* **完全移除乘法器**
* cycle 數不變

---
所有檔案在.tar裡面，自己下載起來練習吧!

